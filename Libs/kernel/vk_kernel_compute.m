%% VK_KERNEL_COMPUTE Compute a viability kernel approximation
%
% SYNOPSIS
%   This function takes a constraint set, an array of differential
%   equations, and a maximum absolute control magnitude, and attempts to
%   compute an approximate viability kernel, by dividing the state-space
%   into a discretised set of points (according to the `discretisation'
%   option specified in `options'), and calling a viability-determination
%   algorithm (usually vk_viable) against each point.
%
%   In addition to the three arguments that this function accepts, additional
%   options can be passed in either as (name, value) pairs, or as a structure
%   generated by vk_options.
%
%   vk_kernel_compute makes use of cellfun by splitting the problem space into
%   discretisation-many sub-problems, which are then passed into cellfun.
%   This is useful because in GNU Octave, parcellfun can be used as a
%   drop-in replacement for cellfun to simultaneously consider the
%   viability of multiple points, using parallel processing.  For MATLAB(R), we
%   have written an implementation of cellfun called vk_cellfun_parfor which
%   facilitates parallel processing when the Parallel Toolkit is available.
%   The choice of cell function to use can be altered by changing the `cell_fn'
%   option (see vk_options).
%
% USAGE
%   % Standard way of calling:
%   V = vk_kernel_compute(k, f, c)
%
%       - `K' is the constraint set, a row vector twice as long as the number
%         of variables,
%
%   % Passing in an options structure, constructed by vk_options:
%   V = vk_kernel_compute(K, f, c, options)
%
%   % Using the default options, except for some specified here:
%   V = vk_compute(K, f, c, ...
%       'name1', value1, ...
%       'name2', value2 [, ...])
%
%   % Using an options structure, and modifying some parameters:
%   V = vk_kernel_compute(K, f, c, options, ...
%       'name1', value1, ...
%       'name2', value2 [, ...])
%
% EXAMPLES
%   % Compute a simple viability kernel
%   K = [0, 1, 0, 1]    % Two dimensions, each with the same upper and
%                       % lower bounds.
%   f = @(x, u) [1/2*x(1) + x(2)*u; u];
%   V = vk_kernel_compute(K, f, 0.001);
%
%   % Compute the same kernel with a higher discretisation
%   V = vk_kernel_compute(K, f, 0.001, 'discretisation', [50, 50]);
%
%   % Compute the same kernel again, but this time using PARCELLFUN
%   V = vk_kernel_compute(K, f, 0.001, ...
%       'discretisation, [50, 50], ...
%       'cell_fn', @(varargin) parcellfun(2, varargin{:}, 'UniformOutput', false));
%
% Requires:  vk_kernel_compute_recursive, vk_options
%
% See also: cellfun, parcellfun, vk_cellfun_parfor, vk_viable

%%
%  Copyright 2011 Jacek B. Krawczyk and Alastair Pharo
%
%  Licensed under the Apache License, Version 2.0 (the "License");
%  you may not use this file except in compliance with the License.
%  You may obtain a copy of the License at
%
%      http://www.apache.org/licenses/LICENSE-2.0
%
%  Unless required by applicable law or agreed to in writing, software
%  distributed under the License is distributed on an "AS IS" BASIS,
%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%  See the License for the specific language governing permissions and
%  limitations under the License.
function [V, NV, viable_paths nonviable_paths] = vk_kernel_compute(K, f, c, varargin)

    %% Build options.
    options = vk_options(K, f, c, varargin{:});

    %% These are the options that we are interested in.
    numvars = options.numvars;
    discretisation = options.discretisation;

    %% Create vectors of points for each dimension
    %   LINSPACE is used to accomplish this.  Discretisation in each dimension
    %   is potentially different.
    ax = cell(numvars, 1);
    for i = 1:numvars
        ax{i} = linspace(K(2*i - 1), ...
            K(2*i), discretisation(i));
    end

    %% Create a function for use with CELLFUN
    %   This function wraps the VK_KERNEL_COMPUTE_RECURSIVE helper function
    %   prepopulating all variables except for 'start' and 'posn'.  See
    %   VK_KERNEL_COMPUTE_RECURSIVE, below.
    fn = @(start, posn) vk_kernel_compute_recursive(...
        zeros(prod(discretisation(2:end)), numvars), ...
        zeros(prod(discretisation(2:end)), numvars), ...
        cell(prod(discretisation(2:end)), 1), cell(prod(discretisation(2:end)), 1), ...
        start, 0, 0, posn, ...
        ax(2:end), K, f, c, options);

    %% Create a cell of 'starts'.
    %   These are used by progress feedback functions to tell how far along the
    %   algorithm is.
    start_cells = cell(1, discretisation(1));
    for i = 1:discretisation(1)
        start_cells{i} = (i - 1) * prod(discretisation(2:end));
    end

    %% Call CELLFUN or PARCELLFUN
    [V_cells, NV_cells, viable_path_cells, nonviable_path_cells, cnt_cells, ncnt_cells] = ...
        options.cell_fn(fn, start_cells, num2cell(ax{1}));


    %% Build the viability kernel from the results of the CELLFUN call
    V = zeros(sum(cell2mat(cnt_cells)), numvars);
    viable_paths = cell(sum(cell2mat(cnt_cells)), 1);
    c = 0;
    for i = 1:discretisation(1)
        V(c+1:c+cnt_cells{i}, :) = V_cells{i}(1:cnt_cells{i},:);
        viable_paths(c+1:c+cnt_cells{i}) = viable_path_cells{i}(1:cnt_cells{i});
        c = c + cnt_cells{i};
    end

    % Build the 'anti-kernel' in the same way.
    NV = zeros(sum(cell2mat(ncnt_cells)), numvars);
    nonviable_paths = cell(sum(cell2mat(ncnt_cells)), 1);
    c = 0;
    for i = 1:discretisation(1)
        NV(c+1:c+ncnt_cells{i}, :) = NV_cells{i}(1:ncnt_cells{i},:);
        nonviable_paths(c+1:c+ncnt_cells{i}) = nonviable_path_cells{i}(1:ncnt_cells{i});
        c = c + ncnt_cells{i};
    end
end


%% VK_KERNEL_COMPUTE_RECURSIVE Recursive helper function for VK_KERNEL_COMPUTE
%   This is a recursive function that takes  calls a viability function on each
%   one.  It returns an untrucated list of viable points, along with a counter
%   of how many points in the list are viable (hence it is easy to truncate
%   this list as needed).
%
%
%
%   - 'start' indicates how many computations will have been undertaken
%     by the time that the sub-problem in question is called (assuming
%     that computation is not occuring in parallel).  This is used to
%     display progress information during computation.
%
%   - 'posn' is a (possibly partially constructed) point to consider.  In those
%     cases where posn is not fully constructed, points are taken from the ax
%     variable to produce points.
function [V, NV, viable_paths, nonviable_paths, cnt, ncnt] = ...
    vk_kernel_compute_recursive(V, NV, ...
        viable_paths, nonviable_paths, ...
        start, cnt, ncnt, posn, ax, ...
        K, f, c, options)

    cancel_test = options.cancel_test;
    discretisation = options.discretisation;

    % More than one axis still under consideration -- call
    % vk_kernel_compute_recursive on the subset of points.
    if (length(ax) > 1)
        curr_ax = ax{1};
        for i = 1:length(curr_ax)
            if (cancel_test && options.cancel_test_fn())
                break;
            end

            s = start + (i-1) * prod(discretisation(length(posn)+2:end));
            [V, NV, viable_paths, nonviable_paths, cnt ncnt] = ...
                vk_kernel_compute_recursive(V, NV, ...
                    viable_paths, nonviable_paths, s, cnt, ncnt, ...
                    [posn; curr_ax(i)], ax(2:end), K, f, c, options);
        end
    else % Only one axis remaining -- call options.viable_fn on each point.
        curr_ax = ax{1};
        for i = 1:length(curr_ax)
            if (cancel_test && options.cancel_test_fn())
                break;
            end

            x = [posn; curr_ax(i)];

            if (options.debug)
                disp(start + i);
                disp(transpose(x));
            end

            if (options.report_progress)
                options.progress_fn(start + i);
            end

            try
              [viable, viable_path] = options.viable_fn(x, K, f, c, options);

              if (viable)
                  cnt = cnt + 1;
                  V(cnt, :) = transpose(x);
                  viable_paths{cnt} = viable_path;
              else
                  ncnt = ncnt + 1;
                  NV(ncnt, :) = transpose(x);
                  nonviable_paths{ncnt} = viable_path;
              end

            catch
              exception = lasterror();
              warning(['Error computing viability of point ', ...
                mat2str(transpose(x)), ...
                ': ', ...
                exception.message]);
            end
        end
    end
end
